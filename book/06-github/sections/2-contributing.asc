=== Як зробити внесок до проекту

Тепер, коли ваш обліковий запис налаштовано, розгляномо деякі подробиці, що можуть стати вам у нагоді при роботі над вже існуючим проектом.

==== Робимо форк проекту

(((forking)))
Якщо ви бажаєте зробити внесок до існуючого проекту, проте у вас немає права на викладання до нього змін, ви можете створити ``форк'' (`fork`) проекту.
Це означає, що GitHub створить копію проекту, що є повністю вашою. Вона існує в просторі імен вашого користувача, ви можете викладати до неї зміни.

[NOTE]
====
Історично термін ``форк'' має дещо негативне забарвлення, зазвичай це означало, що хтось узяв проект з відкритим кодом та повів його в іншому напрямку, іноді створюючи конкуруючий проект та забираючи частину розробників.
У GitHub ``форк'' - це просто той самий проект у вашому власному просторі імен, що дозволяє вам робити зміни до проекту публічно, це засіб зробити внесок у більш відкритій спосіб.
====

Таким чином, проектам не доводиться піклуватися про надання користувачам права на викладання змін.
Кожен може створити форк проекту, викласти до нього зміни, та додати свої зміни до оригінального сховища за допомогою ``Запита на Забирання Змін'' (Pull Request), про який ми поговоримо далі.
Цей запит відкриває нитку дискусії з можливістю переглядати код, власник та автор змін можуть спілкуватися про зміни доки власник не стане ними задоволений, після чого власник може злити зміни до свого сховища.

Щоб зробити форк проекту, зайдіть на сторінку проекту та натисніть на кнопку ``Fork'' зверху праворуч.

.Кнопка ``Fork''.
image::images/forkbutton.png[Кнопка ``Fork''.]

Через декілька секунд, ви опинитесь на сторінці вашого нового проекту, з вашою власною копією коду, яку ви можете змінювати.


[[_github_flow]]
==== Потік роботи GitHub

(((GitHub, Flow)))
GitHub був спроектований навколо конкретного методу співпраці, в центрі якого Запит на Пул.
Цей метод працює і в разі співпраці у маленькій команді в одному спільному сховищі, і в глобальній розподіленій компанії, чи мережі незнайомців, які допомагають проекту через десятки форків.
Він базується на процесі роботи <<_topic_branch>>, який ми вже розглянули в <<_git_branching>>.

Ось як це в цілому працює:

1. Створіть гілку на основі `master`, в ній ви будете робити всі свої зміни.
2. Зробіть якісь коміти, що поліпшують проект.
3. Викладайте цю гілку до свого проекту GitHub.
4. Відкрийте Запит на Пул за допомогою GitHub.
5. Обговоріть зміни, можливо зробіть ще декілька комітів.
6. Власник проекту заливає до проекту Запит на Пул, або закриває його.

Це дуже схоже на процес роботи Integration Manager, який ми розглянули в <<_integration_manager>>, проте замість використання електронної пошти для спілкування та огляду змін, команди використовують інструменти сайту GitHub.

Детально розглянемо приклад того, як запропонувати зміни до проекту з відкритим кодом, що зберігає код на GitHub, за допомогою цієї схеми.

===== Створення запиту на пул

Тоні шукає код, який можна запустити на його мікроконтролері на платі Arduino, та знайшов чудовий програмний файл на GitHub за адресою https://github.com/schacon/blink[].

.Проект, до якого ми хочемо зробити внесок.
image::images/blink-01-start.png[Проект, до якого ми хочемо зробити внесок.]

Єдина проблема в тому, що частота миготіння занадто велика, ми гадаємо, що набагато краще чекати 3 секунди замість 1 між кожною зміною стану.
Отже ми покращуємо програму та надсилаємо назад до проекту як пропоновану зміну.

Спочатку, ми натискаємо на кнопку 'Fork', як ми згадували раніше, щоб отримати нашу власну копію проекту.
Наше ім'я користувача тут ``tonychacon'', отже наша копія проекту має адресу `https://github.com/tonychacon/blink' і саме за цією адресою ми можемо її редагувати.
Ми зробимо локальний клон, створимо гілку для наших змін, зробимо зміни в коді та нарешті викладемо ці зміни назад до GitHub.

[source,console]
----
$ git clone https://github.com/tonychacon/blink <1>
Cloning into 'blink'...

$ cd blink
$ git checkout -b slow-blink <2>
Switched to a new branch 'slow-blink'

$ sed -i '' 's/1000/3000/' blink.ino <3>

$ git diff --word-diff <4>
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
}

$ git commit -a -m 'three seconds is better' <5>
[slow-blink 5ca509d] three seconds is better
 1 file changed, 2 insertions(+), 2 deletions(-)

$ git push origin slow-blink <6>
Username for 'https://github.com': tonychacon
Password for 'https://tonychacon@github.com':
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch]      slow-blink -> slow-blink
----

<1> Клонуємо наш форк проекту локально
<2> Створюємо окрему гілку зі зрозумілою назвою
<3> Робимо наші зміни в коді
<4> Перевіряємо, що зміни вірні
<5> Робимо коміт наших змін до своєї гілки
<6> Викладаємо нашу нову гілку назад до нашого форку GitHub.

Тепер, якщо ми повернемося до нашого форку на GitHub, ми можемо бачити, що GitHub помітив, що ми виклали нову гілку та виводить нам велику зелену кнопку щоб продивитись наші зміни та відкрити Запит на Пул до оригінального проекту.

Також ви можете перейти до сторінки ``Branches'' (гілки) за адресою `https://github.com/<user>/<project>/branches`, щоб знайти вашу гілку та відкрити новий Запит на Пул звідти.

.Кнопка Запит на Пул (Pull Request)
image::images/blink-02-pr.png[Кнопка Запит на Пул (Pull Request)]

(((GitHub, pull requests)))
Якщо ми натиснемо на цю зелену кнопку, ми побачимо сторінку, що просить надати нашому Запиту на злиття назву та опис.
Майже завжди варто попрацювати над цим, оскільки гарний опис допомагає власнику оригінального проекту визначити, що ви намагалися зробити, чи правильні зміни ви пропонуєте, і чи прийняття цих змін поліпшить проект.

Ми також бачимо список комітів вашої гілки, які ``ahead'' (попереду) гілки `master` (у цьому випадку тільки один) та об'єднану різницю (unified diff) від усіх змін, що будуть зроблені, якщо цю гілку зіллє власник проекту.

.Сторінка створення Запиту на Пул
image::images/blink-03-pull-request-open.png[Сторінка створення Запиту на Пул]

Коли ви натиснете кнопку 'Create pull request' (створити запит на пул) на цій сторінці, власник проекту, від якого ви створили форк, отримає повідомлення про те, що хтось пропонує зміни з посиланням на сторінку, що містить усю інформацію про ці зміни.

[NOTE]
====
Хоч Запити на Пул зазвичай використовують у відкритих проектах так, як описано вище - коли зміни вже повністю готові, Запити на Пул також часто використовуються у внутрішніх проектах _на початку_ циклу розробки. Оскільки ви можете продовжувати заливати зміни до гілки навіть *після* відкриття Запиту на Пул, нерідко його відкривають завчасно та використовують як спосіб ітеративного доопрацювання в команді, а не відкривають наприкінці процесу.
====

===== Ітеративне доопрацювання за допомогою Запита на Пул

Тепер власник проекту може подивитися на пропоновані зміни та злити їх з проектом, відмовитись від них або прокоментувати їх. Припустимо, що ідея йому подобається, проте він бажає щоб світлодіод трохи довше був увімкнутим та вимкненим.

У представленому в <<_distributed_git>> процесі роботи обговорення б проходило через електронну пошту, а на GitHub усе обговорення йде прямо на сайті. Власник проекту може продивлятись об'єднану різницю (unified diff) та залишити коментар, якщо він просто натисне на будь-який з рядків.

.Коментування окремого рядка коду в Запиті на Пул
image::images/blink-04-pr-comment.png[Коментування окремого рядка коду в Запиті на Пул]

Коли супроводжувач (maintainer) зробить цей коментар, людина, що відкрила Запит на Пул (та насправді будь-хто, хто слідкує за сховищем) отримає повідомлення. Ми розглянемо прилаштування цього пізніше, проте якщо в нього були ввімкнені поштові повідомлення, Тоні отримає такого листа:

[[_email_notification]]
.Коментарі, що їх відправили як поштові повідомлення
image::images/blink-04-email.png[Поштове повідомлення]

Хто завгодно може залишати загальні коментарі до Запиту на Пул. У <<_pr_discussion>> ми можемо побачити приклад того, як власник проекту прокоментував і окремий рядок коду, і залишив загальний коментар у секції обговорення. Ви можете побачити, що коментарі до коду також є частиною обговорення.

[[_pr_discussion]]
.Сторінка обговорення Запиту на Пул
image::images/blink-05-general-comment.png[Сторінка обговорення Запиту на Пул]

Тепер автори змін можуть бачити, що їм треба зробити, щоб їх зміни прийняли.
На щастя це дуже просто зробити.
Якби ви використовували пошту для спілкування, вам довелося б переробити ваші зміни та знову відправляти їх до поштової розсилки (mailing list), а за допомогою GitHub ви можете просто знову зробити коміт до своєї гілки та викласти зміни до GitHub, що автоматично оновить Запит на злиття.
На <<_pr_final>> ви також можете бачити, що коментарі до старого коду сховано в оновленому запиті на злиття, оскільки вони були зроблені до рядків, які відтоді змінилися.

Додавання комітів до існуючого запиту на злиття не спричиняє повідомлень, отже щойно Тоні надіслав свої виправлення, він вирішує залишити коментар, щоб проінформувати власників проекту, що він зробив потрібну зміну.

[[_pr_final]]
.Фінальний Запит на Пул
image::images/blink-06-final.png[Фінальний Запит на Пул]

Зверніть увагу на те, що якщо ви натиснете на вкладку ``Files Changed'' (змінені файли) цього Запиту на Пул, ви отримаєте ``об'єднану'' різницю -- тобто, повну агреговану різницю, яка буде додана до вашої головної гілки, якщо гілка зі змінами буде до неї злита. У термінах `git diff`, це просто автоматично виконана команда `git diff master...<гілка>`, для гілки, на якій базується цей Запит на Пул. Зверніться до <<_what_is_introduced>> задля докладнішим описом цього типу різниці.

Ще ви помітите, що GitHub сам перевіряє, чи Запит на Пул може бути чисто злитим (без конфліктів) та показує кнопку для злиття прямо на сервері. Ця кнопка відображається тільки якщо у вас є доступ на запис до сховища та просте злиття можливе. Якщо ви на неї натиснете, GitHub зробить злиття ``не-швидко-вперед'' (`non-fast-forward`), тобто навіть якщо злиття могло бути здійснено `швидко-вперед`, все одно буде створений коміт злиття.

Якщо ви бажаєте, ви можете просто отримати гілку та злити її локально. Якщо ви зіллєте цю гілку до гілки `master` та викладете її до GitHub, Запит на Пул автоматично стане закритим.

Це базовий процес роботи, який використовує більшість проектів GitHub. Створюєте окрему гілку, одкриваєте Запит на Злиття для неї, виникає обговорення, можливо доводиться допрацювати цю гілку та нарешті запит або закривають, або зливають до проекту.

[NOTE]
.Не Тільки Форки
====
Важливо зазначити, що ви можете відкрити Запит на Пул між двома гілками одного сховища. Якщо ви працюєте над функціоналом з кимось та ви обидвоє маєте доступ на запис до проекту, ви можете викласти окрему гілку до сховища та відкрити Запит на Пул з неї до гілки `master` того ж самого проекту, щоб розпочати процес перевірки та обговорення коду. Нема потреби створювати форк.
====

==== Глибше про Запити на Пул

Ми розглянули основи того, як робити внесок до проекту на GitHub, розглянемо декілька цікавих порад та хитрощів про Запити на Пул, щоб ви могли користуватись ними ефективніше.

===== Запити на Пул як Патчі

Важливо розуміти, що багато проектів не розглядають Запити на Пул як чергу ідеальних патчів, які мають чисто накладатись саме в цьому порядку, як більшість основаних на поштових списках проектів розглядає послідовність патчів. Більшість проектів GitHub розглядають гілки Запитів на Пул як інтерактивну бесіду про запропоновані зміни, їх цікавить тільки результуючі зміни, які додаються до проекту за допомогою злиття.

Це важлива відмінність, адже зазвичай зміни пропонуються до того, як код доводять до ідеалу, що є дуже рідкісним у проектах, які використовують поштові списки з послідовностями патчів для співпраці. Це дозволяє обговоренню з супроводжувачем проекту розпочатись раніше, тому вірне рішення досягається спільними зусиллями. Коли код пропонується за допомогою Запита на Пул, та супроводжувачі або спільнота пропонує зміну, послідовність патчів зазвичай не створюється заново, а замість цього зміни просто викладаються як новий коміт до гілки, що просуває обговорення далі без втрати контексту попередньої праці.

Наприклад, якщо ви повернетесь та знову подивитесь на <<_pr_final>>, ви можете помітити, що автор змін не робив перебазування свого коміту та не відправляв ще один Запит на Пул. Натомість він додав нові коміти та виклав їх до існуючої гілки. Таким чином, якщо ви повернетесь до цього Запиту на Пул у майбутньому, ви легко знайдете весь контекст всіх прийнятих рішень. При натисканні на кнопку ``Merge'' (злити) на сайті, GitHub навмисно створює коміт злиття з посиланням на Запит на Пул, щоб було легко повернутись та досліджувати обговорення при необхідності.

===== Йдемо в ногу з оригінальним проектом

Якщо ваш Запит на Пул стає застарілим, чи не може бути чисто злитим через щось інше, ви забажаєте виправити його, щоб супроводжувач проекту міг легко злити ваші зміни. GitHub перевіряє це та повідомляє вам наприкінці кожного Запиту на Пул чи може він бути злитим без конфліктів.

[[_pr_fail]]
.Запит на Пул не може бути злитим чисто
image::images/pr-01-fail.png[Невдача при злитті Запиту на Пул]

Якщо ви бачите щось схоже на <<_pr_fail>>, ви захочете виправити свою гілку щоб зображення стало зеленим та супроводжувачу не довелося виконувати зайвої праці.

У вас є два основних варіанти, як це зробити. Ви можете перебазувати вашу гілку поверх цільової гілки (зазвичай це гілка `master` сховища, від якого ви зробили форк), або ви можете злити цільову гілку до вашої гілки.

Більшість розробників на GitHub обирають другий варіант через вже зазначені раніше причини. Важлива історія та фінальне злиття, а перебазування дає нам тільки трохи чистішу історію натомість воно *набагато* складніше та в цьому варіанті легше наробити помилок.

Якщо ви бажаєте злити цільову гілку до вашої, щоб з’явилася можливість чисто злити ваш Запит на Пул, вам слід додати оригінальне сховище як нове віддалене сховище, зробити з нього фетч, злити головну гілку цього сховища до вашої гілки, виправити будь-які проблеми та нарешті залити це до гілки, на яку відкритий Запит на Пул.

Наприклад, припустимо, що в наведеному вище прикладі ``tonychacon'', автор оригінального проекту зробив зміни, які призводять до конфлікту в Запиті на Пул. Розглянемо що треба робити покроково.

[source,console]
----
$ git remote add upstream https://github.com/schacon/blink <1>

$ git fetch upstream <2>
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch]      master     -> upstream/master

$ git merge upstream/master <3>
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.

$ vim blink.ino <4>
$ git add blink.ino
$ git commit
[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \
    into slower-blink

$ git push origin slow-blink <5>
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
   ef4725c..3c8d735  slower-blink -> slow-blink
----

<1> Додаємо оригінальне сховище як віддалене під ім’ям ``upstream''
<2> Отримаємо останні зміни з цього сховища
<3> Зливаємо головну гілку до нашої
<4> Виправляємо конфлікти
<5> Заливаємо зміни назад до тієї ж нашої гілки

Щойно ви це зробите, Запит на Пул буде автоматично оновлений та знову пройде перевірка на можливість чистого злиття.

[[_pr_merge_fix]]
.Тепер Запит на Злиття можна злити чисто
image::images/pr-02-merge-fix.png[виправлений Запит На Злиття]

Одна з чудових рис Git полягає в тому, що ви можете це робити постійно. Якщо у вас дуже довготривалий проект, ви легко можете зливати з цільової гілки знов і знов та вам доведеться вирішувати тільки ті конфлікти, що виникли після останнього злиття, що дозволяє якось впоратися з процесом.

Якщо ви все одно бажаєте перебазувати гілку, щоб її почистити, ви безумовно можете це зробити, проте ми дуже рекомендуємо не заливати зміни насилу (force push) до гілки, для якої ви відкрили Запит на Злиття. Якщо інші люди взяли цю гілку та щось з нею робили, ви наштовхнетеся на багато труднощів, які описані в <<_rebase_peril>>. Замість цього, залийте перебазовану гілку до нової гілки на GitHub та відкривайте абсолютно новий Запит на Пул з посиланням на попередній, та закривайте перший.

===== Посилання

Можливо ваше наступне питання ``А як мені зробити посилання на попередній Запит на Пул?''. Виявляється є дуже багато методів зробити посилання на інші речі будь-де, де ви можете писати на GitHub.

Почнемо з перехресних посилань між Запитом на Пул та Завданням (`Issue`). Усім Запитам на Злиття та Завданням присвоєні номери, що є унікальними в межах проекту. Наприклад, у вас може бути Запит на Пул #3 _та_ Завдання #3. Якщо ви бажаєте послатись на будь-який Запит на Злиття чи Завдання з будь-якого іншого, ви можете просто написати `#<номер>` в будь-якому коментарі чи описі. Ви також можете бути більш детальними, якщо Завдання чи Запит на Пул знаходяться деінде. Пишіть `<ім’я користувача>#<номер>`, якщо ви хочете послатись на Завдання чи Запит на Пул у форку поточного сховища, або `<ім’я користувача>/<назва сховища>#<номер>`, щоб послатись на щось в іншому сховищі.

Розглянемо приклад. Припустимо, ми перебазували гілку в попередньому прикладі, створили новий запит на пул для неї, та тепер хочемо послатися на попередній запит на пул з нового. Ми також бажаємо послатись на завдання у форку сховища та на завдання з зовсім іншого проекту. Ми можемо заповнити поле опису як у <<_pr_references>>.

[[_pr_references]]
.Перехресні посилання в Запиті на Пул
image::images/mentions-01-syntax.png[Посилання в Запиті на Пул]

Коли ми відправимо цей запит на пул, ми побачимо, що він відображається як <<_pr_references_render>>.

[[_pr_references_render]]
.Відображення перехресних посилань у Запиті на Пул
image::images/mentions-02-render.png[Відображення посилань у Запиті на Пул]

Зверніть увагу на те, що повний GitHub URL, що ми ввели, був скорочений саме так, щоб передати всю необхідну інформацію.

Тепер якщо Тоні повернеться назад та закриє оригінальний Запит на Пул, ми зможемо це побачити згадку про це в новому, адже GitHub автоматично створить подію зворотного стеження (`trackback event`) у хронології попереднього Запиту на Пул. Це означає, що будь-хто, хто зайде до цього Запиту на Пул та побачить, що він закритий, легко зможе перейти до сторінки запиту, що його замінив. Посилання буде виглядати приблизно як <<_pr_closed>>.

[[_pr_closed]]
.Відображення перехресного посилання в Запиті на Пул.
image::images/mentions-03-closed.png[Закритий запит]

Крім номерів завдань, ви також можете посилатись на окремий коміт за його SHA-1. Вам доведеться вказати всі 40 символів SHA-1, проте якщо GitHub побачить це в коментарі, він зробить посилання прямо на коміт. Знову ж таки, ви можете посилатись на коміти у форках чи інших сховищах саме так, як ви це робили із завданнями.

==== Markdown

Зв’язок з іншими завданнями це тільки мала частина цікавих речей, які ви можете робити майже в будь-якому текстовому полі на GitHub. В описах Завдань та Запитів на Пул, у коментарях, у коментарях до коду та ще багато де, ви можете використовувати так званий ``GitHub різновид Markdown'' (`GitHub Flavored Markdown`). Markdown це простий текст, який відображається з форматуванням.

<<_example_markdown>> містить приклад того, як коментарі або текст можуть бути написані та відображені за допомогою Markdown.

[[_example_markdown]]
.Приклад написання та відображення Markdown
image::images/markdown-01-example.png[Приклад Markdown]

===== GitHub різновид Markdown

GitHub різновид Markdown додає деякі речі поза базовим синтаксисом Markdown. Вони можуть бути дуже корисними при створенні докладних описів Запитів на Пул або Завдань або коментарів до них.

====== Списки завдань

Перша дійсно корисна специфічна для GitHub функція Markdown, особливо при використанні з Запитами на Пул, це Список Завдань (`Task List`). Список завдань це список прапорців (`checkbox`) речей, які ви хочете зробити. Зазвичай його додають до Завдання або Запиту на Пул, щоб написати список речей, які мають бути виконані до того, як можна вважати роботу завершеною.

Ви можете створити список завдань так:

[source,text]
----
- [X] Write the code
- [ ] Write all the tests
- [ ] Document the code
----

Якщо ми додамо це до опису нашого Запиту на Пул або Завдання, воно буде відображатись як <<_task_list>>

[[_task_lists]]
.Відображення списку завдань Markdown у коментарі.
image::images/markdown-02-tasks.png[Приклад Списку Завдань]

Список завдань часто використовується в Запиті на Пул щоб позначити необхідні доопрацювання гілки, до того як Запит на Пул буде готовим до злиття. Дійсно чудове те, що ви можете просто натиснути на прапорець щоб оновити коментар -- вам нема потреби редагувати код Markdown щоб змінювати позначку біля задачі.

Більш того, GitHub шукає список задач у ваших Завданнях та Запитах на Пул і відображає їх як метадані на сторінках, що виводять їх список. Наприклад, якщо ви маєте Запит на Пул із задачами та ви дивитесь на оглядову сторінку Запитів на Пул, ви зможете побачити як багато вже зроблено. Це допомагає людям розбити Запити на Пул на дрібніші завдання, та допомагає іншим слідкувати за прогресом гілки. Ви можете подивитись на приклад цього в <<_task_list_progress>>.

[[_task_list_progress]]
.Підсумок списку задач у списку Запитів на Пул.
image::images/markdown-03-task-summary.png[Приклад Списку Задач]

Це неймовірно корисно, коли ви відкриваєте Запит на Пул заздалегідь та використовуєте його, щоб слідкувати за своїм прогресом під час написання нової функції.

====== Уривки коду

Ви також можете додавати уривки коду до коментарів. Це особливо корисно, якщо ви хочете показати щось, що ви _могли б_ спробувати до того, як дійсно створювати такий коміт у своїй гілці. Їх також часто використовують щоб додати приклад коду, що не працює, чи коду, який міг би використати цей Запит на Пул.

Щоб додати уривок коду, вам треба ``огородити'' (`fence`) його зворотними апострофами.

[source,text]
----
```java
for(int i=0 ; i < 5 ; i++)
{
   System.out.println("i is : " + i);
}
```
----

Якщо додати назву мови, як ми зробили зараз (коли написали 'java'), GitHub також спробує підсвітити синтаксис уривку.

[[_md_code]]
.Відображення прикладу відгородженого коду.
image::images/markdown-04-fenced-code.png[Відображення відгородженого коду]

====== Цитування

Якщо ви відповідаєте на маленьку частину довгого коментаря, ви можете вибірково процитувати частину іншого коментаря, якщо поставите на початку кожного рядка знак `>`. Насправді, це настільки поширена та корисна функція, що на клавіатурі для цього є окреме поєднання клавіш. Якщо ви виділите текст у коментарі, на який ви хочете відповісти та натиснете клавішу `r`, відкриється форма коментарю з вже процитованим для вас текстом.

Цитування виглядають приблизно так:

[source,text]
----
> Whether 'tis Nobler in the mind to suffer
> The Slings and Arrows of outrageous Fortune,

How big are these slings and in particular, these arrows?
----

При відображенні коментар буде виглядати як <<_md_quote>>.

[[_md_quote]]
.Відображення прикладу цитування.
image::images/markdown-05-quote.png[Відображення цитування]

====== Емодзі

Нарешті, ви також можете використовувати емодзі у ваших коментарях. Насправді їх використовують доволі широко в коментарях, їх можна побачити в багатьох Завданнях та Запитах на Пул GitHub. У GitHub навіть існує помічник емодзі.

[[_md_emoji_auto]]
.Автодоповнювач Емодзі в дії.
image::images/markdown-06-emoji-complete.png[Емодзі автодоповнювач]

Емодзі мають форму `:<назва>:` будь-де у коментарі. Наприклад, ви можете написати щось таке:

[source,text]
----
I :eyes: that :bug: and I :cold_sweat:.

:trophy: for :microscope: it.

:+1: and :sparkles: on this :ship:, it's :fire::poop:!

:clap::tada::panda_face:
----

При відображенні, це виглядатиме приблизно як <<_md_emoji>>.

[[_md_emoji]]
.Сповнений емодзі коментар.
image::images/markdown-07-emoji.png[Емодзі]

Не те щоб це дуже корисно, проте додає елемент розваги та емоцій до носія, в якому доволі важко передати емоції іншим чином.


[NOTE]
====
Насправді доволі багато веб сервісів використовують символи емодзі. Чудова шпаргалка для пошуку емодзі, що виражає потрібну вам емоцію знаходиться за адресою:

http://www.emoji-cheat-sheet.com
====

====== Зображення

Технічно це не є частиною Різновиду Markdown GitHUb, проте дуже корисно. На додаток до стандартного додавання посилань на зображення Markdown, що може бути доволі складним через необхідність шукати та вбудовувати URL, GitHub дозволяє вам просто перетягнути зображення до області вводу тексту, щоб вбудувати їх.

[[_md_drag]]
.Перетягування зображень щоб відвантажити та автоматично вбудувати їх.
image::images/markdown-08-drag-drop.png[Перетягування зображень]

Якщо ви знову поглянете на <<_pr_references>>, то побачите маленьку підказку ``Parsed as Markdown'' (оброблено як Markdown) над текстовим полем. Якщо ви натиснете на неї, вам нададуть повну шпаргалку всього, що ви можете робити за допомогою Markdown на GitHub.
